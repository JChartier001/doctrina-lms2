---
alwaysApply: true
---

# TypeScript Best Practices

This file contains TypeScript-specific rules and best practices for the entire codebase.

## üö´ CRITICAL RULE: No `any` Types

**NEVER use `any` types in production code. This is a hard rule with ONE exception: test files.**

### Instead of `any`, use:

```typescript
// ‚ùå WRONG - Never do this
const data: any = fetchData();
function process(obj: any) { /* ... */ }
const handler = (event: any) => { /* ... */ };

// ‚úÖ CORRECT - Proper alternatives
// 1. Define specific types
interface UserData {
  id: string;
  name: string;
}
const data: UserData = fetchData();

// 2. Use unknown for truly unknown values
const unknownData: unknown = fetchData();
if (isUserData(unknownData)) {
  process(unknownData);
}

// 3. Use union types
type ResponseData = UserData | ErrorData;

// 4. Use generics
function process<T extends BaseData>(obj: T): T { /* ... */ }

// 5. Use Record for dynamic objects
const dynamicObj: Record<string, unknown> = {};
```

### Exception: Test Files

```typescript
// ‚úÖ OK in test files only (*.test.ts, *.test.tsx)
describe("Component tests", () => {
  it("handles mock data", () => {
    const mockData: any = { /* test data */ };
    // any is permitted here for testing flexibility
  });
});
```

## Type Definitions

### Always Use Explicit Return Types

```typescript
// ‚ùå WRONG - Implicit return type
const calculateTotal = (items: Item[]) => {
  return items.reduce((sum, item) => sum + item.price, 0);
};

// ‚úÖ CORRECT - Explicit return type
const calculateTotal = (items: Item[]): number => {
  return items.reduce((sum, item) => sum + item.price, 0);
};

// For React components
const MyComponent = (props: Props): JSX.Element => {
  return <div>{props.content}</div>;
};

// For async functions
const fetchData = async (id: string): Promise<UserData> => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};
```

### Interfaces vs Type Aliases

```typescript
// ‚úÖ PREFER interfaces for object shapes
interface User {
  id: string;
  name: string;
  email: string;
}

// Interfaces can be extended
interface AdminUser extends User {
  permissions: string[];
}

// ‚úÖ USE type aliases for:
// 1. Union types
type Status = "pending" | "approved" | "rejected";

// 2. Intersection types
type UserWithTimestamps = User & {
  createdAt: Date;
  updatedAt: Date;
};

// 3. Utility types
type PartialUser = Partial<User>;
type UserKeys = keyof User;

// 4. Function types
type ClickHandler = (event: MouseEvent) => void;
```

## Strict Type Checking

### tsconfig.json Settings

```json
{
  "compilerOptions": {
    "strict": true,                    // Enable all strict checks
    "noImplicitAny": true,            // Error on implicit any
    "strictNullChecks": true,          // Enable strict null checks
    "strictFunctionTypes": true,       // Strict function types
    "strictBindCallApply": true,       // Strict bind/call/apply
    "strictPropertyInitialization": true, // Class property initialization
    "noImplicitThis": true,           // Error on implicit this
    "alwaysStrict": true,             // Emit "use strict"
    "noUnusedLocals": true,           // Error on unused locals
    "noUnusedParameters": true,       // Error on unused parameters
    "noImplicitReturns": true,        // Error when not all paths return
    "noFallthroughCasesInSwitch": true // Error on fallthrough cases
  }
}
```

## Common Types and Patterns

### Discriminated Unions

```typescript
// ‚úÖ Use discriminated unions for state management
type LoadingState = {
  status: "idle";
} | {
  status: "loading";
} | {
  status: "success";
  data: UserData;
} | {
  status: "error";
  error: Error;
};

// Using with as const
const ACTION_TYPES = {
  FETCH: "FETCH",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
} as const;

type ActionType = typeof ACTION_TYPES[keyof typeof ACTION_TYPES];
```

### Utility Types

```typescript
// Partial - Make all properties optional
type PartialUser = Partial<User>;

// Required - Make all properties required
type RequiredUser = Required<User>;

// Readonly - Make all properties readonly
type ReadonlyUser = Readonly<User>;

// Pick - Select specific properties
type UserCredentials = Pick<User, "email" | "password">;

// Omit - Exclude specific properties
type PublicUser = Omit<User, "password">;

// Record - Create object type with specific keys
type UserRoles = Record<string, Role>;

// Extract/Exclude - Filter union types
type NumbersOnly = Extract<string | number | boolean, number>;
type NoNumbers = Exclude<string | number | boolean, number>;

// NonNullable - Remove null and undefined
type DefinedUser = NonNullable<User | null | undefined>;

// ReturnType - Get function return type
type FunctionReturn = ReturnType<typeof myFunction>;

// Parameters - Get function parameters as tuple
type FunctionParams = Parameters<typeof myFunction>;
```

### Type Guards

```typescript
// Type predicate functions
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === "object" &&
    obj !== null &&
    "id" in obj &&
    "name" in obj &&
    "email" in obj
  );
}

// Using type guards
const processData = (data: unknown): void => {
  if (isUser(data)) {
    // data is typed as User here
    console.log(data.email);
  }
};

// Narrowing with typeof
function processValue(value: string | number) {
  if (typeof value === "string") {
    // value is string here
    return value.toUpperCase();
  } else {
    // value is number here
    return value * 2;
  }
}

// Narrowing with instanceof
function handleError(error: unknown) {
  if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error("Unknown error", error);
  }
}
```

### Generics

```typescript
// Generic functions
function identity<T>(value: T): T {
  return value;
}

// Generic interfaces
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// Generic classes
class DataStore<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  get(index: number): T | undefined {
    return this.items[index];
  }
}

// Generic constraints
interface HasId {
  id: string;
}

function findById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// Multiple type parameters
function map<T, U>(items: T[], fn: (item: T) => U): U[] {
  return items.map(fn);
}
```

## Arrays and Objects

### Array Types

```typescript
// ‚úÖ CORRECT - Always define array types explicitly
const numbers: number[] = [1, 2, 3];
const users: User[] = [];
const matrix: number[][] = [[1, 2], [3, 4]];

// Using Array<T> syntax
const items: Array<string> = ["a", "b", "c"];

// Readonly arrays
const readonlyNumbers: ReadonlyArray<number> = [1, 2, 3];
// or
const readonlyStrings: readonly string[] = ["a", "b"];

// Tuple types
const tuple: [string, number, boolean] = ["hello", 42, true];

// Rest parameters
function sum(...numbers: number[]): number {
  return numbers.reduce((a, b) => a + b, 0);
}
```

### Object Types

```typescript
// ‚úÖ CORRECT - Define object shapes
interface Product {
  id: string;
  name: string;
  price: number;
  tags?: string[];  // Optional property
  readonly sku: string;  // Readonly property
}

// Index signatures
interface StringDictionary {
  [key: string]: string;
}

// Nested objects
interface Order {
  id: string;
  customer: {
    name: string;
    email: string;
  };
  items: Array<{
    productId: string;
    quantity: number;
  }>;
}

// Using Record type
const userRoles: Record<string, Role> = {
  admin: { permissions: ["all"] },
  user: { permissions: ["read"] },
};
```

## Function Types

### Function Signatures

```typescript
// Function type aliases
type ClickHandler = (event: MouseEvent) => void;
type AsyncCallback<T> = (data: T) => Promise<void>;
type Predicate<T> = (item: T) => boolean;

// Function overloads
function createElement(tag: "a"): HTMLAnchorElement;
function createElement(tag: "div"): HTMLDivElement;
function createElement(tag: string): HTMLElement {
  return document.createElement(tag);
}

// Optional and default parameters
function greet(name: string, greeting: string = "Hello"): string {
  return `${greeting}, ${name}!`;
}

// Rest parameters with types
function combine<T>(...arrays: T[][]): T[] {
  return arrays.flat();
}
```

## Async Types

### Promise Types

```typescript
// Async function return types
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// Promise with union types
async function tryFetchUser(id: string): Promise<User | null> {
  try {
    return await fetchUser(id);
  } catch {
    return null;
  }
}

// Async error handling
type AsyncResult<T> = Promise<
  | { success: true; data: T }
  | { success: false; error: Error }
>;

async function safeOperation<T>(
  operation: () => Promise<T>
): AsyncResult<T> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

## Module Types

### Import/Export Types

```typescript
// Type-only imports/exports
import type { User } from "./types";
export type { User };

// Namespace imports
import * as Types from "./types";

// Module augmentation
declare module "express" {
  interface Request {
    user?: User;
  }
}

// Ambient declarations
declare global {
  interface Window {
    customAPI: {
      version: string;
    };
  }
}
```

## React Types

### Component Types

```typescript
import { FC, ReactNode, PropsWithChildren } from "react";

// Function component with props
interface ButtonProps {
  onClick: () => void;
  variant?: "primary" | "secondary";
  disabled?: boolean;
}

const Button: FC<ButtonProps> = ({ onClick, variant = "primary", disabled }) => {
  return <button onClick={onClick} disabled={disabled}>{/* ... */}</button>;
};

// Component with children
interface LayoutProps {
  title: string;
  children: ReactNode;
}

const Layout: FC<PropsWithChildren<LayoutProps>> = ({ title, children }) => {
  return (
    <div>
      <h1>{title}</h1>
      {children}
    </div>
  );
};

// Event handlers
const handleClick = (event: React.MouseEvent<HTMLButtonElement>): void => {
  event.preventDefault();
};

const handleChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
  console.log(event.target.value);
};
```

## Best Practices

1. **Never use `any`** (except in test files)
2. **Always specify return types** for functions
3. **Use `unknown` instead of `any`** for truly unknown types
4. **Prefer interfaces** for object shapes
5. **Use type aliases** for unions and intersections
6. **Enable strict mode** in tsconfig.json
7. **Use const assertions** for literal types
8. **Define explicit types** for arrays and objects
9. **Use type guards** for runtime type checking
10. **Leverage utility types** to avoid repetition
11. **Use discriminated unions** for state machines
12. **Type event handlers** properly in React

## Common Mistakes to Avoid

```typescript
// ‚ùå Using any
const data: any = fetchData();

// ‚úÖ Use proper types or unknown
const data: UserData = fetchData();

// ‚ùå Implicit any in functions
function process(data) { }

// ‚úÖ Explicit parameter types
function process(data: UserData): void { }

// ‚ùå Using Function type
const callback: Function = () => {};

// ‚úÖ Specific function signature
const callback: () => void = () => {};

// ‚ùå Non-null assertions without checks
const value = possiblyNull!.property;

// ‚úÖ Proper null checking
const value = possiblyNull?.property;

// ‚ùå Type assertions without validation
const user = response as User;

// ‚úÖ Validate before asserting
if (isUser(response)) {
  const user = response;
}
```